import { setns, mapHosts } from "./util.ns";

function printCCT(ns, cct) {
    ns.tprintf("%s %s:", cct.host, cct.name);
    ns.tprintf("  %s", cct.type);
    ns.tprintf("  %s", cct.desc);
    ns.tprintf("  %s", cct.data);
}

class CCT {
    constructor(ns, hostname, filename) {
		this.name = filename;
		this.host = hostname;
		this.type = ns.codingcontract.getContractType(filename, hostname);
		this.desc = ns.codingcontract.getDescription(filename, hostname);
		this.data = ns.codingcontract.getData(filename, hostname);

		this.solve = _.bind(CCT["solve" + this.type.replace(/\s/g, "")], null, _, this)
	}
	print(ns) {
		ns.tprintf("%s %s:", this.host, this.name);
		ns.tprintf("  %s", this.type);
		ns.tprintf("  %s", this.desc);
		ns.tprintf("  %s", this.data);
	}
    static solveTotalWaystoSum(ns, cct) {
		/*
		It is possible write four as a sum in exactly four different ways:
	  
			3 + 1
			2 + 2
			2 + 1 + 1
			1 + 1 + 1 + 1

			//////////

			1 1 1 1 1 1 1 1
			2 1 1 1 1 1 1
			3 1 1 1 1 1
			4 1 1 1 1
			5 1 1 1
			6 1 1
			7 1
			=============  XX increment the 2nd factor, start the first factor on the same as the 2nd
			2 2 1 1 1 1
			3 2 1 1 1
			4 2 1 1
			5 2 1
			6 2
			=============
			3 3 1 1
			4 3 1
			=============
			4 4
			=============  XX increment the 3rd factor, start the 1st and second on the same as the 3rd
			2 2 2 1 1
			2 2 2 2
			3 2 2 1
			4 2 2
			=============
			3 3 2

			===================================================
			1111111111
			211111111
			31111111
			4111111
			511111
			61111
			7111
			811
			91
			--------------------------- 2nd factor
			22111111
			3211111
			421111
			52111
			6211
			721
			82
			------- 2
			331111
			43111
			5311
			631
			73
			------- 2
			4411
			541
			64
			------- 2
			55
			-------------------------- 3rd factor
			2221111
			322111
			42211
			5221
			622
			-------- 2
			33211
			4321
			432
			-------- 2
			442
			-------- 2
			3331
			433
			--------------------------- 4th factor
			222211
			32221
			4222
			------- 2
			3322

			==========================
			1111111111
			222222222
			33333333
			4444444
			555555
			66666
			7777
			888
			99

			1111111111
			222222221
			33333321
			4444321
			554321
			65432
			7654
			876
			98

			 1111111111 O
			
			2 11111111 O
			1 11111111 X

			32 111111 X
			31 111111 O
			22 111111 O
			21 111111 X
			11 111111 X

			432 1111 X
			431 1111 X
			422 1111 X
			421 1111 X
			411 1111 O
			332 1111 X
			331 1111 X
			322 1111 X
			321 1111 O
			311 1111 X
			222 1111 O
			221 1111 X
			211 1111 X
			111 1111 X

			5432 11
			5431 11
			5422 11
			5421 11
			5411 11
			5332 11
			5331 11
			5322 11
			5321 11
			5311 11
			5222 11
			5221 11
			5211 11
			5111 11 O
			4432 11
			4431 11
			4422 11
			4421 11
			4411 11
			4332 11
			4331 11
			4322 11
			4321 11
			4311 11
			4222 11
			4221 11
			4211 11 O
			4111 11
			3332 11
			3331 11
			3322 11
			3321 11
			3311 11 O
			3222 11
			3221 11 O
			3211 11
			3111 11
			2222 11 O
			2222 11
			2221 11
			2211 11
			2111 11
			1111 11

			65432

			7654

			876

			98

			increment 1st factor
			increment 1st factor, remove last factor until ther are no more 1s
			increment 2nd factor, remove last factor, increment 1st factor until it matches 2nd factor
				increment 1st factor, remove last factor intil ther are no more 1s
			increment 2nd factor, remove last factor until there are no more 1s




	  
		How many different ways can the number 30 be written as a sum of at least two positive integers?

		start with N = target to account for 1*N (1)
		keep increasing the 1st factor by 1 unil it's just N-1 + 1 (N-1)

		*/


        let target = this.data
    }
    static solveSubarraywithMaximumSum(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveSpiralizeMatrix(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveArrayJumpingGame(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveMergeOverlappingIntervals(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveGenerateIPAddresses(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveAlgorithmicStockTraderI(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveAlgorithmicStockTraderII(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveAlgorithmicStockTraderIII(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveAlgorithmicStockTraderIV(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveMinimumPathSuminaTriangle(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveUniquePathsinaGridI(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveUniquePathsinaGridII(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveSanitizeParenthesesinExpression(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveFindAllValidMathExpressions(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
	static solveFindLargestPrimeFactor(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
}

/** @param {import(".").NS } ns */
export async function main(ns) {
    setns(ns);

    let hosts = mapHosts();
    let ccts = [];
    for (const [hostname, trail] of Object.entries(hosts)) {
        let ls = ns.ls(hostname).filter((filename) => filename.indexOf(".cct") !== -1);

        if (ls.length === 0) continue;

        ccts.push(new CCT(ns, hostname, ls[0]));
    }

	for (const cct of ccts) {
		cct.solve(ns)
	}
}
