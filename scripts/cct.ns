import { setns, mapHosts } from "./util.ns";

function printCCT(ns, cct) {
    ns.tprintf("%s %s:", cct.host, cct.name);
    ns.tprintf("  %s", cct.type);
    ns.tprintf("  %s", cct.desc);
    ns.tprintf("  %s", cct.data);
}

class CCT {
    constructor(ns, hostname, filename) {
		this.name = filename;
		this.host = hostname;
		this.type = ns.codingcontract.getContractType(filename, hostname);
		this.desc = ns.codingcontract.getDescription(filename, hostname);
		this.data = ns.codingcontract.getData(filename, hostname);

		this.solve = _.bind(CCT["solve" + this.type.replace(/\s/g, "")], null, _, this)
	}
	print(ns) {
		ns.tprintf("%s %s:", this.host, this.name);
		ns.tprintf("  %s", this.type);
		ns.tprintf("  %s", this.desc);
		ns.tprintf("  %s", this.data);
	}
    static solveTotalWaystoSum(ns, cct) {
		/*
		It is possible write four as a sum in exactly four different ways:
	  
			3 + 1
			2 + 2
			2 + 1 + 1
			1 + 1 + 1 + 1

			//////////

			1 1 1 1 1 1 1 1
			2 1 1 1 1 1 1
			3 1 1 1 1 1
			4 1 1 1 1
			5 1 1 1
			6 1 1
			7 1
			=============  XX increment the 2nd factor, start the first factor on the same as the 2nd
			2 2 1 1 1 1
			3 2 1 1 1
			4 2 1 1
			5 2 1
			6 2
			=============
			3 3 1 1
			4 3 1
			=============
			4 4
			=============  XX increment the 3rd factor, start the 1st and second on the same as the 3rd
			2 2 2 1 1
			2 2 2 2
			3 2 2 1
			4 2 2
			=============
			3 3 2

			===================================================
			1111111111
			211111111
			31111111
			4111111
			511111
			61111
			7111
			811
			91
			-------
			22111111
			3211111
			421111
			52111
			6211
			721
			82
			-------
			331111
			43111
			5311
			631
			73
			-------
			4411
			541
			64
			-------
			55
			--------
			2221111
			322111
			42211
			5221
			622
			--------
			33211
			4321
			432
			--------
			442
			--------
			


	  
		How many different ways can the number 30 be written as a sum of at least two positive integers?

		start with N = target to account for 1*N (1)
		keep increasing the 1st factor by 1 unil it's just N-1 + 1 (N-1)

		*/


        let target = this.data
    }
    static solveSubarraywithMaximumSum(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveSpiralizeMatrix(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveArrayJumpingGame(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveMergeOverlappingIntervals(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveGenerateIPAddresses(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveAlgorithmicStockTraderI(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveAlgorithmicStockTraderII(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveAlgorithmicStockTraderIII(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveAlgorithmicStockTraderIV(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveMinimumPathSuminaTriangle(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveUniquePathsinaGridI(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveUniquePathsinaGridII(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveSanitizeParenthesesinExpression(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
    static solveFindAllValidMathExpressions(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
	static solveFindLargestPrimeFactor(ns, cct) {
        ns.tprintf("WARNING: TODO: Write solver for cct's of type '%s' to solve %s:%s", cct.type, cct.host, cct.name);
    }
}

/** @param {import(".").NS } ns */
export async function main(ns) {
    setns(ns);

    let hosts = mapHosts();
    let ccts = [];
    for (const [hostname, trail] of Object.entries(hosts)) {
        let ls = ns.ls(hostname).filter((filename) => filename.indexOf(".cct") !== -1);

        if (ls.length === 0) continue;

        ccts.push(new CCT(ns, hostname, ls[0]));
    }

	for (const cct of ccts) {
		cct.solve(ns)
	}
}
