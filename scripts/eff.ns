import { allHosts, serverIsHackable, setns, softenServer, doProgramBuys, canExecuteOnServer } from "./util.ns";

/** @param {import(".").NS } ns */
function calcHackAmount(ns, host, _target, ramAllowance) {
    let player = ns.getPlayer();
    let target = ns.getServer(_target.hostname);
    target.hackDifficulty = target.minDifficulty;

    let growRam = ns.getScriptRam("grow.ns"); // 1.75GB
    let weakenRam = ns.getScriptRam("weaken.ns"); // 1.75GB
    let hackRam = ns.getScriptRam("hack.ns"); // 1.70GB

    let targetHackAmount = target.moneyMax * 0.99;
    let targetHackPercent = targetHackAmount / target.moneyMax;
    let hackPercent = ns.formulas.hacking.hackPercent(target, player);
    let hackThreads = Math.ceil(targetHackPercent / hackPercent);
    let hackAmount = hackThreads * hackPercent * target.moneyMax;

    let growThreads = calcMinGrowThreads(ns, host, target, hackAmount);

    let weakenAmountPerThread = ns.weakenAnalyze(1, host.cpuCores);

    let hackSecIncrease = ns.hackAnalyzeSecurity(hackThreads);
    let growSecIncrease = ns.growthAnalyzeSecurity(growThreads);
    let hackWeakenThreads = Math.ceil(hackSecIncrease / weakenAmountPerThread);
    let growWeakenThreads = Math.ceil(growSecIncrease / weakenAmountPerThread);
    let hackRamCycle =
        hackThreads * hackRam + growThreads * growRam + (hackWeakenThreads + growWeakenThreads) * weakenRam;

    if (hackRamCycle > ramAllowance) {
        let failRatio = ramAllowance / hackRamCycle;
        targetHackAmount = Math.min(targetHackAmount * (failRatio * 1.1), targetHackAmount);
        targetHackPercent = targetHackAmount / target.moneyMax;
        hackThreads = Math.ceil(targetHackPercent / hackPercent);
    }

    while (hackRamCycle > ramAllowance) {
        hackThreads--;
        if (hackThreads === 0) return 0;

        hackAmount = hackThreads * hackPercent * target.moneyMax;

        growThreads = calcMinGrowThreads(ns, host, target, hackAmount);

        hackSecIncrease = ns.hackAnalyzeSecurity(hackThreads);
        growSecIncrease = ns.growthAnalyzeSecurity(growThreads);
        hackWeakenThreads = Math.ceil(hackSecIncrease / weakenAmountPerThread);
        growWeakenThreads = Math.ceil(growSecIncrease / weakenAmountPerThread);
        hackRamCycle =
            hackThreads * hackRam + growThreads * growRam + (hackWeakenThreads + growWeakenThreads) * weakenRam;
    }

    // ns.tprintf("  H: %d/%.2fGB; G: %d/%.2fGB; W: %d|%d/%.2fGB; T: %.2fGB (%s, %.2f%% of Max)",
    //     hackThreads, hackThreads * hackRam,
    //     growThreads, growThreads * growRam,
    //     hackWeakenThreads, growWeakenThreads, (hackWeakenThreads + growWeakenThreads) * weakenRam,
    //     hackRamCycle, ns.nFormat(hackAmount, "($0.000a)"), hackAmount / target.moneyMax * 100)

    return hackAmount * ns.formulas.hacking.hackChance(target, player);
}

/** @param {import(".").NS } ns */
function calcMinGrowThreads(ns, host, _target, hackAmount) {
    let player = ns.getPlayer();
    let target = ns.getServer(_target.hostname);
    target.hackDifficulty = target.minDifficulty;

    let targetGrowMult = 1;
    if (hackAmount < 1) targetGrowMult = target.moneyMax / (target.moneyMax * hackAmount);
    else targetGrowMult = target.moneyMax / (target.moneyMax - hackAmount);

    let growThreads = Math.ceil(ns.growthAnalyze(target.hostname, targetGrowMult, host.cpuCores));
    while (ns.formulas.hacking.growPercent(target, --growThreads, player, host.cpuCores) > targetGrowMult);

    return growThreads + 1;
}

/** @param {import(".").NS } ns */
function calcHackRate(ns, host, _target, ramAllowance) {
    let target = _target;
    let player = ns.getPlayer();
    if (typeof target === "string" || target instanceof String) target = ns.getServer(target);

    if (target.moneyMax <= 0) return 0;

    target.hackDifficulty = target.minDifficulty;

    let tweaken = ns.formulas.hacking.weakenTime(target, player) / 1000;
    let hackAmount = calcHackAmount(ns, host, target, ramAllowance);

    return hackAmount / tweaken;
}

/** @param {import(".").NS } ns */
function getRamAllowance(ns, _host) {
    let host = _host;
    if (typeof host === "string" || host instanceof String) host = ns.getServer(host);

    let ramAllowance = host.maxRam;
    if (host.hostname === "home") ramAllowance -= 64;

    return ramAllowance;
}

/** @param {import(".").NS } ns */
function getOrderedTargetArr(ns, _host) {
    let host = _host;
    if (typeof host === "string" || host instanceof String) host = ns.getServer(host);

    let ramAllowance = getRamAllowance(ns, host);
    let hackRates = [];
    let targetnames = allHosts()
        .filter(serverIsHackable)
        .filter((hostname) => ns.getServerMaxMoney(hostname) > 0);
    for (let targetname of targetnames) {
        hackRates.push([targetname, calcHackRate(ns, host, targetname, ramAllowance)]);
    }

    return hackRates.sort((a, b) => b[1] - a[1]);
}

/** @param {import(".").NS } ns */
function testOutput(ns) {
    let player = ns.getPlayer();
    let host = ns.getServer("home");
    let targetnames = getOrderedTargetArr(ns, host);

    for (let [targetname, hackrate] of targetnames) {
        let target = ns.getServer(targetname);
        target.moneyAvailable = target.moneyMax;
        target.hackDifficulty = target.minDifficulty;

        let tweaken = ns.formulas.hacking.weakenTime(target, player) / 1000;
        let ramAllowance = getRamAllowance(ns, host);
        let hackAmount = calcHackAmount(ns, host, target, ramAllowance);

        ns.tprintf(
            "%20s %10s/s %10s [%-2.2f%% of Max] every %s (hackrate: %s)",
            target.hostname,
            ns.nFormat(hackAmount / tweaken, "($0.000a)"),
            ns.nFormat(hackAmount, "($0.000a)"),
            (hackAmount / target.moneyMax) * 100,
            ns.tFormat(tweaken * 1000),
            ns.nFormat(hackrate, "($0.000a)")
        );
    }
}

function removeTarget(arr, key, value) {
    let i = 0;
    while (i < arr.length) {
        if (arr[i][key] === value) {
            arr.splice(i, 1);
        } else {
            ++i;
        }
    }
    return arr;
}

/** @param {import(".").NS } ns */
export async function main(ns) {
    setns(ns);

    let player = ns.getPlayer();
    let allHostnames = allHosts();
    let attackScript = "dispatcher.ns";

    doProgramBuys();

    // soften all servers
    for (const hostName of allHostnames) {
        softenServer(hostName);
        await ns.scp(attackScript, "home", hostName)
    }

    // create a dictionary mapping server size to server name array (with a special bucket for "home")
    let hostSizeDict = {};
    for (let hostname of allHostnames.filter(canExecuteOnServer)) {
        let key = ns.getServerMaxRam(hostname);

        if (hostname === "home") key = "home";

        if (!(key in hostSizeDict)) hostSizeDict[key] = [];

        hostSizeDict[key].push(hostname);
    }

    // create a dictionary mapping host server sizes to ordered target arrays
    let targetArrDict = {};
    let badhosts = [];
    for (const [key, value] of Object.entries(hostSizeDict)) {
        let orderedTargetArr = getOrderedTargetArr(ns, value[0]);
        if (orderedTargetArr[0][1] === 0) {
            //ns.tprintf("Host %s does not have enough ram (%d) to execute a hack script", value[0], ns.getServerMaxRam(value[0]))
            badhosts.push(value[0]);
        } else {
            targetArrDict[key] = orderedTargetArr;
        }
    }

    // purge hosts that can't sustain hack scripts
    for (let hostname of badhosts) {
        delete hostSizeDict[hostname];
    }

    // collect target arrays into a single array ordered by value and including the server size bucket information
    let allTargets = [];
    for (const [key, values] of Object.entries(targetArrDict)) {
        for (let value of values) {
            allTargets.push({
                size: key,
                targetname: value[0],
                income: value[1],
            });
        }
    }
    allTargets = allTargets.sort((a, b) => b.income - a.income);

    // Set up tracker to decide how many targets are needed for each bucket
    let bucketTracker = {};
    for (const [key, value] of Object.entries(hostSizeDict)) {
        bucketTracker[key] = value.length;
    }

    // Iterate over allTargets, taking the next best target/bucket pair and removing all lesser targets in the
    // array. If all hosts in a bucket are accounted for, remove all lesser targets using that bucket. Finish
    // iterating once either all host servers are accounted for, or we've run out of targets.
    let finalTargets = [];
    while (allTargets.length > 0) {
        let target = allTargets.shift();
        allTargets = allTargets.filter((t) => target.targetname !== t.targetname);

        if (--bucketTracker[target.size] === 0) {
            allTargets = allTargets.filter((t) => target.size !== t.size);
        }

        finalTargets.push(target);
    }

    // Assign a target to a host in the target's bucket. Kill all hosts that are attacking targets not in this bucket.
    // Check to see if a host in the target's bucket is already attacking the target. If it is, skip the target. Otherwise
    // kick off attack on that target.
    for (const [bucket, hostnames] of Object.entries(hostSizeDict)) {
        // get all targets for this bucket
        let targetnames = [];
        for (let target of finalTargets) {
            if (target.size === bucket) targetnames.push(target.targetname);
        }

        //ns.tprintf("%s: [%s] [%s]", bucket, targetnames, hostnames)

        // iterate over all hosts in this bucket, killing processes on any that are attacking something not in targets and
        // removing targets from the target array that are already being attacked
        for (let hostname of hostnames) {
            let ps = ns.ps(hostname);
            let dokill = false;
            for (let psInfo of ps) {
                if (psInfo.filename === attackScript) {
                    let attackTargetnameIdx = targetnames.indexOf(psInfo.args[0]);
                    if (attackTargetnameIdx === -1) {
                        ns.tprintf("Killing %s running on %s targeting %s", attackScript, hostname, psInfo.args[0]);
                        dokill = true;
                    } else {
                        targetnames.splice(attackTargetnameIdx, 1);
                    }
                    break;
                }
            }

            // If we're killing on home, make sure to only kill attack scripts so we dont kill ourselves
            if (dokill) {
                if (hostname !== "home") {
                    ns.killall(hostname);
                } else {
                    for (let psInfo of ps) {
                        if (
                            psInfo.filename === attackScript ||
                            psInfo.filename === "weaken.ns" ||
                            psInfo.filename === "grow.ns" ||
                            psInfo.filename === "hack.ns"
                        ) {
                            ns.kill(psInfo.filename, hostname, psInfo.args);
                        }
                    }
                }
            }
        }

        // In case all the targets are accounted for, continue to the next bucket
        if (targetnames.length === 0) continue;

        // iterate over all hosts in this bucket, if the host is free, run the attack script on it with one of the targets
        for (let hostname of hostnames) {
            let ps = ns.ps(hostname);
            let hostfree = true;
            for (let psInfo of ps) {
                if (psInfo.filename === attackScript) {
                    hostfree = false;
                    break;
                }
            }

            if (hostfree) {
                let targetname = targetnames.shift();
                ns.tprintf("Starting %s on %s targeting %s", attackScript, hostname, targetname);

                if (!ns.fileExists(attackScript, hostname)) await ns.scp(attackScript, "home", hostname);

                ns.exec(attackScript, hostname, 1, targetname);
            }

            if (targetnames.length === 0)
                break
        }
    }

    for (let target of finalTargets) {
        ns.tprintf(
            "%20s: %10s/s %s",
            target.targetname,
            ns.nFormat(target.income, "($0.000a)"),
            target.size.toString()
        );
    }

    /*
    Algorithm:
        collect target arrays for each server size for all purchased servers and home
        collate targets per income for all servers of size purchasedServers.length + 1 (+1 for home) ???
        go down list from top to bottom, inspect servers at the same tier to see if the current target is being run at that tier
            if the target is being run at that tier, continue to the next target
            else kill the lowest producing target and start the current target on the newly freed server
        when starting a new target, specify the income of the target in the arg list so it can be compared later

    Colate:
        Iterate over all tier arrays at the same time
        Compare current item on all arrays, pick item with the highest income
        if item.server is not in the master list, pop the item, add the item to the master list and increment a tracking variable for that tier
            if the tier is full (tracker === tier.length) then clear out that tier's list or stop tracking it
        if item.server is in the master list already, pop the item without adding it to the list
        if all tiers are full, you're done

    Launching new dispatcher:
        scp dispatcher.ns to the host server, exec dispatcher.ns with the target, 1 thread
    */
}
