/** @type import(".").NS */
let ns = null;

import { allHosts, serverIsHackable, setns } from "./util.ns";

function calcHackAmount(host, _target, ramAllowance) {
    let player = ns.getPlayer();
    let target = ns.getServer(_target.hostname);
    target.hackDifficulty = target.minDifficulty;

    let growRam = ns.getScriptRam("grow.ns"); // 1.75GB
    let weakenRam = ns.getScriptRam("weaken.ns"); // 1.75GB
    let hackRam = ns.getScriptRam("hack.ns"); // 1.70GB

    let targetHackAmount = target.moneyMax * 0.5;
    let targetHackPercent = targetHackAmount / target.moneyMax;
    let hackPercent = ns.formulas.hacking.hackPercent(target, player);
    let hackThreads = Math.ceil(targetHackPercent / hackPercent);
    let hackAmount = hackThreads * hackPercent * target.moneyMax;

    let growThreads = calcMinGrowThreads(host, target, hackAmount);

    let weakenAmountPerThread = ns.weakenAnalyze(1, host.cpuCores);

    let hackSecIncrease = ns.hackAnalyzeSecurity(hackThreads);
    let growSecIncrease = ns.growthAnalyzeSecurity(growThreads);
    let hackWeakenThreads = Math.ceil(hackSecIncrease / weakenAmountPerThread);
    let growWeakenThreads = Math.ceil(growSecIncrease / weakenAmountPerThread);
    let hackRamCycle =
        hackThreads * hackRam + growThreads * growRam + (hackWeakenThreads + growWeakenThreads) * weakenRam;

    if (hackRamCycle > ramAllowance) {
        let failRatio = ramAllowance / hackRamCycle;
        targetHackAmount = Math.min(targetHackAmount * (failRatio * 1.1), targetHackAmount);
        targetHackPercent = targetHackAmount / target.moneyMax;
        hackThreads = Math.ceil(targetHackPercent / hackPercent);
    }

    while (hackRamCycle > ramAllowance) {
        hackThreads--;
        hackAmount = hackThreads * hackPercent * target.moneyMax;

        growThreads = calcMinGrowThreads(host, target, hackAmount);

        hackSecIncrease = ns.hackAnalyzeSecurity(hackThreads);
        growSecIncrease = ns.growthAnalyzeSecurity(growThreads);
        hackWeakenThreads = Math.ceil(hackSecIncrease / weakenAmountPerThread);
        growWeakenThreads = Math.ceil(growSecIncrease / weakenAmountPerThread);
        hackRamCycle =
            hackThreads * hackRam + growThreads * growRam + (hackWeakenThreads + growWeakenThreads) * weakenRam;
    }

    // ns.tprintf("  H: %d/%.2fGB; G: %d/%.2fGB; W: %d|%d/%.2fGB; T: %.2fGB (%s, %.2f%% of Max)",
    //     hackThreads, hackThreads * hackRam,
    //     growThreads, growThreads * growRam,
    //     hackWeakenThreads, growWeakenThreads, (hackWeakenThreads + growWeakenThreads) * weakenRam,
    //     hackRamCycle, ns.nFormat(hackAmount, "($0.000a)"), hackAmount / target.moneyMax * 100)

    return hackAmount * ns.formulas.hacking.hackChance(target, player);
}

function calcMinGrowThreads(host, _target, hackAmount) {
    let player = ns.getPlayer();
    let target = ns.getServer(_target.hostname);
    target.hackDifficulty = target.minDifficulty;

    let targetGrowMult = 1;
    if (hackAmount < 1) targetGrowMult = target.moneyMax / (target.moneyMax * hackAmount);
    else targetGrowMult = target.moneyMax / (target.moneyMax - hackAmount);

    let growThreads = Math.ceil(ns.growthAnalyze(target.hostname, targetGrowMult, host.cpuCores));
    while (ns.formulas.hacking.growPercent(target, --growThreads, player, host.cpuCores) > targetGrowMult);

    return growThreads + 1;
}

function calcHackRate(host, _target, ramAllowance) {
    let target = _target;
    let player = ns.getPlayer();
    if (typeof target === "string" || target instanceof String) target = ns.getServer(target);

    target.hackDifficulty = target.minDifficulty;

    let tweaken = ns.formulas.hacking.weakenTime(target, player) / 1000;
    let hackAmount = calcHackAmount(host, target, ramAllowance);

    return hackAmount / tweaken;
}

/** @param {NS} _ns **/
export async function main(_ns) {
    ns = _ns;

    setns(ns);

    let player = ns.getPlayer();

    let host = ns.getServer("home");
    let ramAllowance = host.maxRam - 32;

    let hostnames = allHosts()
        .filter(serverIsHackable)
        .filter((hostname) => ns.getServerMaxMoney(hostname) > 0)
        .sort((a, b) => calcHackRate(host, b, ramAllowance) - calcHackRate(host, a, ramAllowance));

    for (let hostname of hostnames) {
        let target = ns.getServer(hostname);
        target.moneyAvailable = target.moneyMax;
        target.hackDifficulty = target.minDifficulty;

        let tweaken = ns.formulas.hacking.weakenTime(target, player) / 1000;
        let hackAmount = calcHackAmount(host, target, ramAllowance);

        ns.tprintf(
            "%20s %s/s %s [%.2f%% of Max] every %s",
            target.hostname,
            ns.nFormat(hackAmount / tweaken, "($0.000a)"),
            ns.nFormat(hackAmount, "($0.000a)"),
            (hackAmount / target.moneyMax) * 100,
            ns.tFormat(tweaken * 1000)
        );
    }

    /*
    Algorithm:
      collect target arrays for each server size for all purchased servers and home
      collate targets per income for all servers of size purchasedServers.length + 1 (+1 for home) ???
      go down list from top to bottom, inspect servers at the same tier to see if the current target is being run at that tier
        if the target is being run at that tier, continue to the next target
        else kill the lowest producing target and start the current target on the newly freed server
      when starting a new target, specify the income of the target in the arg list so it can be compared later

    Colate:
      Iterate over all tier arrays at the same time
      Compare current item on all arrays, pick item with the highest income
      if item.server is not in the master list, pop the item, add the item to the master list and increment a tracking variable for that tier
        if the tier is full (tracker === tier.length) then clear out that tier's list or stop tracking it
      if item.server is in the master list already, pop the item without adding it to the list
      if all tiers are full, you're done

    Launching new dispatcher:
      scp dispatcher.ns to the host server, exec dispatcher.ns with the target, 1 thread and the raw income/s (for later comparison)
    */
}
