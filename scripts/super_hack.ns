const debug = false;
const TSPACER = 200;
const WEAKENNS = "weaken.ns";
const GROWNS = "grow.ns";
const HACKNS = "hack.ns";

const HackState = {
    UNSET: "UNDEFINED STATE",
    W: "Weaken",
    GW: "Grow and Weaken",
    HW: "Hack and Weaken",
    HGW: "Hack, Grow and Weaken",
};

class HackEnv {
    /** @param {import(".").NS } ns */
    constructor(ns, targetname, hostname = "", ramAllowance = -1, highMoney = -1, lowMoney = -1, tspacer = TSPACER) {
        this.targetname = targetname;
        this.hostname = hostname === "" ? ns.getHostname() : hostname;
        this.ramAllowance =
            ramAllowance === -1
                ? ns.getServerMaxRam(this.hostname) - ns.getServerUsedRam(this.hostname)
                : ramAllowance < 1
                ? (ns.getServerMaxRam(this.hostname) - ns.getServerUsedRam(this.hostname)) * ramAllowance
                : ramAllowance;
        this.highMoney = highMoney === -1 ? ns.getServerMaxMoney(this.targetname) : highMoney;
        this.lowMoney = lowMoney === -1 ? ns.getServerMaxMoney(this.targetname) * 0.05 : lowMoney;
        this.tspacer = tspacer; // CONST
        this.batchHack = false;

        this.cores = 1; // home gets no core benefits to save RAM

        // Target Info
        this.targetSec = 0;
        this.targetSecMin = 0;
        this.targetMoneyAvailable = 0;

        // Weaken Info
        this.weakenRam = 1.75; // CONST
        this.weakenStartSec = 0;
        this.weakenAmountPerThread = 0;
        this.weakenThreads = 0;
        this.weakenThreadsGrow = 0;
        this.weakenThreadsHack = 0;
        this.weakenTime = 0;
        this.weakenTimeFullCycle = 0;

        // Grow Info
        this.growRam = 1.75; // CONST
        this.growStartMoney = 0;
        this.growMult = 0;
        this.growThreads = 0;
        this.growSecIncrease = 0;
        this.growTime = 0;

        // Hack Info
        this.hackRam = 1.7; // CONST
        this.hackStartMoney = 0;
        this.hackTotalEst = 0;
        this.hackTotal = 0;
        this.hackTotalStep = 0;
        this.hackThreads = 0;
        this.hackSecIncrease = 0;
        this.hackTime = 0;
        this.hackPercentPerThread = 0;

        // Batch Cycle Info
        this.ramPerCycle = 0;
        this.cycleSpacer = tspacer * 4;
        this.cycleTarget = 0;
        this.cycleTotal = 0;

        // State Info
        this.state = HackState.UNSET;
    }

    async prep(ns) {
        if (!ns.fileExists(GROWNS, this.hostname)) await ns.scp(GROWNS, "home", this.hostname);
        if (!ns.fileExists(WEAKENNS, this.hostname)) await ns.scp(WEAKENNS, "home", this.hostname);
        if (!ns.fileExists(HACKNS, this.hostname)) await ns.scp(HACKNS, "home", this.hostname);
    }

    /** @param {import(".").NS } ns */
    setState(ns) {
        if (this.isWRunning(ns)) {
            // Process is running on this target, dont update the state
            return;
        }

        if (!this.doneWeaken(ns)) {
            this.state = HackState.W;
            this.weakenStartSec = ns.getServerSecurityLevel(this.targetname);
        } else if (!this.doneGrow(ns)) {
            this.state = HackState.GW;
            this.growStartMoney = ns.getServerMoneyAvailable(this.targetname);
        } else if (this.updateForHGW(ns) || this.hackTotal > this.targetMoneyAvailable * 0.5) {
            // Figure out if the host can support a substantial HGW (defined by a full hack HGW cycle,
            // or the HGW Cycle is hacking at least 50% of the available money). If not, set state to HW
            this.state = HackState.HGW;
            this.hackStartMoney = ns.getServerMoneyAvailable(this.targetname);
        } else {
            this.state = HackState.HW;
            this.hackStartMoney = ns.getServerMoneyAvailable(this.targetname);
        }
    }
    /** @param {import(".").NS } ns */
    refresh(ns) {
        if (this.isWRunning(ns)) {
            // process in progress, wait for next refresh to update
            return;
        }

        if (debug) {
            switch (this.state) {
                case HackState.W:
                    ns.tprintf(
                        "WEAKEN: %s:%s => Lowered Security from %.2f to %.2f (min: %.2f)",
                        this.hostname,
                        this.targetname,
                        this.weakenStartSec,
                        ns.getServerSecurityLevel(this.targetname),
                        ns.getServerMinSecurityLevel(this.targetname)
                    );
                    break;
                case HackState.GW:
                    ns.tprintf(
                        "GROW-WEAKEN: %s:%s => Increased available money from %s to %s/%s [Sec: %.2f]",
                        this.hostname,
                        this.targetname,
                        ns.nFormat(this.growStartMoney, "($0.000a)"),
                        ns.nFormat(ns.getServerMoneyAvailable(this.targetname), "($0.000a)"),
                        ns.nFormat(this.highMoney, "($0.000a)"),
                        ns.getServerSecurityLevel(this.targetname)
                    );
                    break;
                case HackState.HW:
                    let totalHack = this.hackStartMoney - ns.getServerMoneyAvailable(this.targetname);
                    ns.tprintf(
                        "HACK-WEAKEN: %s:%s => Decreased available money from %s to %s; %s Total (%.2f%% of max) [Sec: %.2f]",
                        this.hostname,
                        this.targetname,
                        ns.nFormat(this.hackStartMoney, "($0.000a)"),
                        ns.nFormat(ns.getServerMoneyAvailable(this.targetname), "($0.000a)"),
                        ns.nFormat(totalHack, "($0.000a)"),
                        (totalHack / ns.getServerMaxMoney(this.targetname)) * 100,
                        ns.getServerSecurityLevel(this.targetname)
                    );
                    break;
                case HackState.HGW:
                    ns.tprintf(
                        "HACK-GROW-WEAKEN: %s:%s => Cycle Complete; %s Available; Hacked %s (%.2f%% of max) [Sec: %.2f]",
                        this.hostname,
                        this.targetname,
                        ns.nFormat(ns.getServerMoneyAvailable(this.targetname), "($0.000a)"),
                        ns.nFormat(this.hackTotal, "($0.000a)"),
                        (this.hackTotal / ns.getServerMaxMoney(this.targetname)) * 100,
                        ns.getServerSecurityLevel(this.targetname)
                    );
                    break;
                default:
                    // Do Nothing
                    break;
            }
        }

        this.setState(ns);
        switch (this.state) {
            case HackState.W:
                this.updateForW(ns);
                this.execW(ns);
                break;
            case HackState.GW:
                this.updateForGW(ns);
                this.execGW(ns);
                break;
            case HackState.HW:
                this.updateForHW(ns);
                this.execHW(ns);
                break;
            case HackState.HGW:
                this.updateForHGW(ns);
                this.execHGW(ns);
                break;
            default:
            // Do Nothing
        }
    }

    printRamOverride(ns) {
        let maxRam = ns.getServerMaxRam(this.hostname);
        let ramFraction = maxRam / this.ramAllowance;
        ns.tprintf(
            "Overriding availble host RAM max to %.2f (%.2f%% of %.2f)",
            this.ramAllowance,
            (this.ramAllowance / maxRam) * 100,
            maxRam
        );
    }

    doneWeaken(ns) {
        return ns.getServerSecurityLevel(this.targetname) === ns.getServerMinSecurityLevel(this.targetname);
    }

    doneGrow(ns) {
        return ns.getServerMoneyAvailable(this.targetname) >= this.highMoney;
    }

    /** @param {import(".").NS } ns */
    updateForW(ns, useAllRam = true) {
        // Target Info
        this.targetSec = ns.getServerSecurityLevel(this.targetname);
        this.targetSecMin = ns.getServerMinSecurityLevel(this.targetname);
        let secDiff = this.targetSec - this.targetSecMin;

        // Weaken Info
        this.weakenTime = ns.getWeakenTime(this.targetname);
        this.weakenAmountPerThread = ns.weakenAnalyze(1, this.cores);
        this.weakenThreads = Math.ceil(secDiff / this.weakenAmountPerThread);

        this.ramPerCycle = this.weakenThreads * this.weakenRam;

        if (this.ramPerCycle > this.ramAllowance || useAllRam) {
            this.weakenThreads = Math.floor(this.ramAllowance / this.weakenRam);
            this.ramPerCycle = this.weakenThreads * this.weakenRam;
        }

        // return true if this cycle will fully weaken the target
        return this.weakenThreads * this.weakenAmountPerThread >= secDiff;
    }

    /** @param {import(".").NS } ns */
    updateForGW(ns, useAllRam = true) {
        // Target Info
        this.targetMoneyAvailable = Math.max(ns.getServerMoneyAvailable(this.targetname), 1.0);
        this.targetSec = ns.getServerSecurityLevel(this.targetname);
        this.targetSecMin = ns.getServerMinSecurityLevel(this.targetname);
        let secDiff = this.targetSec - this.targetSecMin;

        // Grow Info
        this.growTime = ns.getGrowTime(this.targetname);
        this.growMult = this.highMoney / this.targetMoneyAvailable;
        this.growThreads = Math.ceil(ns.growthAnalyze(this.targetname, this.growMult, this.cores));
        let growThreadsFull = this.growThreads;
        if (useAllRam) this.growThreads = Math.floor(this.ramAllowance / this.growRam);
        this.growSecIncrease = ns.growthAnalyzeSecurity(this.growThreads);

        // Weaken Info
        this.weakenTime = ns.getWeakenTime(this.targetname);
        this.weakenAmountPerThread = ns.weakenAnalyze(1, this.cores);
        this.weakenThreadsGrow = Math.ceil((this.growSecIncrease + secDiff) / this.weakenAmountPerThread);

        this.ramPerCycle = this.growThreads * this.growRam + this.weakenThreadsGrow * this.weakenRam;

        while (this.ramPerCycle > this.ramAllowance) {
            this.growThreads--;
            this.growSecIncrease = ns.growthAnalyzeSecurity(this.growThreads);
            this.weakenThreadsGrow = Math.ceil((this.growSecIncrease + secDiff) / this.weakenAmountPerThread);
            this.ramPerCycle = this.growThreads * this.growRam + this.weakenThreadsGrow * this.weakenRam;
        }

        // Returning true if this grow cycle will max out the target server
        return this.growThreads >= growThreadsFull;
    }

    /** @param {import(".").NS } ns */
    updateForHW(ns) {
        // Find out how much money I can gain back in a single GW cycle and never hack more than that
        this.updateForGW(ns, true); // to set this.growThreads
        this.growMult = ns.formulas.hacking.growPercent(
            ns.getServer(this.targetname),
            this.growThreads,
            ns.getPlayer(),
            this.cores
        );

        // Target Info
        this.targetMoneyAvailable = ns.getServerMoneyAvailable(this.targetname);
        this.targetSec = ns.getServerSecurityLevel(this.targetname);
        this.targetSecMin = ns.getServerMinSecurityLevel(this.targetname);
        let secDiff = this.targetSec - this.targetSecMin;

        // Hack Info
        this.hackTime = ns.getHackTime(this.targetname);
        this.hackPercentPerThread = ns.hackAnalyze(this.targetname);
        this.hackTotalEst = this.targetMoneyAvailable - this.lowMoney;
        this.hackThreads = Math.ceil(ns.hackAnalyzeThreads(this.targetname, this.hackTotalEst));
        let hackThreadsFull = this.hackThreads;
        this.hackTotal = this.hackPercentPerThread * this.hackThreads * this.targetMoneyAvailable;
        this.hackSecIncrease = ns.hackAnalyzeSecurity(this.hackThreads);

        // Single Cycle Grow Info
        let amountLeftAfterHack = this.targetMoneyAvailable - this.hackTotal;
        let singleCyleGrowAmount = Math.min(amountLeftAfterHack * this.growMult, ns.getServerMaxMoney(this.targetname));

        // Weaken Info
        this.weakenTime = ns.getWeakenTime(this.targetname);
        this.weakenAmountPerThread = ns.weakenAnalyze(1, this.cores);
        this.weakenThreadsHack = Math.ceil((this.hackSecIncrease + secDiff) / this.weakenAmountPerThread);

        this.ramPerCycle = this.hackThreads * this.hackRam + this.weakenThreadsHack * this.weakenRam;

        while (this.ramPerCycle > this.ramAllowance || singleCyleGrowAmount < this.highMoney) {
            this.hackThreads--;
            this.hackTotal = this.hackPercentPerThread * this.hackThreads * this.targetMoneyAvailable;
            this.hackSecIncrease = ns.hackAnalyzeSecurity(this.hackThreads);
            amountLeftAfterHack = this.targetMoneyAvailable - this.hackTotal;
            singleCyleGrowAmount = Math.min(amountLeftAfterHack * this.growMult, ns.getServerMaxMoney(this.targetname));

            this.weakenThreadsHack = Math.ceil((this.hackSecIncrease + secDiff) / this.weakenAmountPerThread);
            this.ramPerCycle = this.hackThreads * this.hackRam + this.weakenThreadsHack * this.weakenRam;
        }

        // Returning true if this hack cycle will bottom out the target server
        return this.hackThreads >= hackThreadsFull;
    }

    /** @param {import(".").NS } ns */
    updateForHGW(ns, useAllRam = true) {
        // Target Info
        this.targetMoneyAvailable = ns.getServerMoneyAvailable(this.targetname);
        this.targetSec = ns.getServerSecurityLevel(this.targetname);
        this.targetSecMin = ns.getServerMinSecurityLevel(this.targetname);
        let secDiff = this.targetSec - this.targetSecMin;

        // Hack Info
        this.hackTime = ns.getHackTime(this.targetname);
        this.hackPercentPerThread = ns.hackAnalyze(this.targetname);
        this.hackTotalEst = this.targetMoneyAvailable - this.lowMoney;
        this.hackThreads = Math.ceil(ns.hackAnalyzeThreads(this.targetname, this.hackTotalEst));
        let hackThreadsFull = this.hackThreads;
        if (useAllRam) this.hackThreads = Math.floor(this.ramAllowance / this.hackRam);
        this.hackTotal = this.hackPercentPerThread * this.hackThreads * this.targetMoneyAvailable;
        if (this.hackTotal >= this.targetMoneyAvailable) {
            this.hackThreads = 1 / this.hackPercentPerThread - 1;
            this.hackTotal = this.hackPercentPerThread * this.hackThreads * this.targetMoneyAvailable;
        }
        this.hackSecIncrease = ns.hackAnalyzeSecurity(this.hackThreads);

        // Grow Info
        this.growTime = ns.getGrowTime(this.targetname);
        this.growMult = this.highMoney / (this.targetMoneyAvailable - this.hackTotal);
        this.growThreads = Math.ceil(ns.growthAnalyze(this.targetname, this.growMult, this.cores));
        this.growSecIncrease = ns.growthAnalyzeSecurity(this.growThreads);

        // Weaken Info
        this.weakenTime = ns.getWeakenTime(this.targetname);
        this.weakenAmountPerThread = ns.weakenAnalyze(1, this.cores);
        this.weakenThreadsHack = Math.ceil((this.hackSecIncrease + secDiff) / this.weakenAmountPerThread);
        this.weakenThreadsGrow = Math.ceil(this.growSecIncrease / this.weakenAmountPerThread);

        this.ramPerCycle =
            this.hackThreads * this.hackRam +
            this.growThreads * this.growRam +
            this.weakenThreadsHack * this.weakenRam +
            this.weakenThreadsGrow * this.weakenRam;

        while (this.ramPerCycle > this.ramAllowance) {
            this.hackThreads--;
            this.hackTotal = this.hackPercentPerThread * this.hackThreads * this.targetMoneyAvailable;
            this.hackSecIncrease = ns.hackAnalyzeSecurity(this.hackThreads);
            this.weakenThreadsHack = Math.ceil((this.hackSecIncrease + secDiff) / this.weakenAmountPerThread);
            this.growMult = this.highMoney / (this.targetMoneyAvailable - this.hackTotal);
            this.growThreads = Math.ceil(ns.growthAnalyze(this.targetname, this.growMult, this.cores));
            this.growSecIncrease = ns.growthAnalyzeSecurity(this.growThreads);
            this.weakenThreadsGrow = Math.ceil(this.growSecIncrease / this.weakenAmountPerThread);

            this.ramPerCycle =
                this.hackThreads * this.hackRam +
                this.growThreads * this.growRam +
                this.weakenThreadsHack * this.weakenRam +
                this.weakenThreadsGrow * this.weakenRam;
        }

        return this.hackThreads >= hackThreadsFull;
    }

    /** @param {import(".").NS } ns */
    execW(ns) {
        ns.exec(WEAKENNS, this.hostname, this.weakenThreads, this.targetname);
    }

    /** @param {import(".").NS } ns */
    execGW(ns) {
        // start grow such that it finishes slightly before weaken
        let growOffsetTime = this.weakenTime - this.tspacer - this.growTime;
        ns.exec(GROWNS, this.hostname, this.growThreads, this.targetname, growOffsetTime);
        ns.exec(WEAKENNS, this.hostname, this.weakenThreadsGrow, this.targetname);
    }

    /** @param {import(".").NS } ns */
    execHW(ns) {
        // start hack such that it finishes slightly before weaken
        let hackOffsetTime = this.weakenTime - this.tspacer - this.hackTime;
        ns.exec(HACKNS, this.hostname, this.hackThreads, this.targetname, hackOffsetTime);
        ns.exec(WEAKENNS, this.hostname, this.weakenThreadsHack, this.targetname);
    }

    /** @param {import(".").NS } ns */
    execHGW(ns) {
        let weakenGrowOffsetTime = this.tspacer * 2;
        let growOffsetTime = this.weakenTime + this.tspacer - this.growTime;
        let hackOffsetTime = this.weakenTime - this.hackTime - this.tspacer;

        ns.exec(WEAKENNS, this.hostname, this.weakenThreadsHack, this.targetname, 0); // hack weaken, Start 1st (0ms offset), finish 2nd
        ns.exec(WEAKENNS, this.hostname, this.weakenThreadsGrow, this.targetname, weakenGrowOffsetTime); // grow weaken, Start 2nd, finish 4th
        ns.exec(GROWNS, this.hostname, this.growThreads, this.targetname, growOffsetTime); // Start 3rd, finish 3rd
        ns.exec(HACKNS, this.hostname, this.hackThreads, this.targetname, hackOffsetTime); // Start 4th, finish 1st
    }

    /** @param {import(".").NS } ns */
    isWRunning(ns) {
        let ps = ns.ps(this.hostname);
        for (let psInfo of ps) {
            if (psInfo.filename === WEAKENNS && psInfo.args.includes(this.targetname)) {
                return true;
            }
        }
        return false;
    }

    /** @param {import(".").NS } ns */
    async waitW(ns) {
        while (this.isWRunning(ns)) {
            await ns.sleep(this.tspacer);
        }
    }
}

//** @param {NS} ns **/
/** @param {import(".").NS } ns */
export async function main(ns) {
    if (!ns.args[0]) {
        ns.tprintf("ERROR: No target server defined");
        return;
    }

    let env = new HackEnv(ns, ns.args[0], ns.args[2], ns.args[1]);
    await env.prep(ns);

    if (debug) env.printRamOverride(ns);
    if (debug) ns.tprintf("INFO: Availble host RAM %.2f", env.ramAllowance);

    while (true) {
        env.refresh(ns);
        await ns.sleep(TSPACER);
    }
}
