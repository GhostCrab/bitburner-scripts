/** @param {NS} ns **/
function serverIsTarget(ns, hostName) {
	const server = ns.getServer(hostName)
	return server.hasAdminRights && (ns.getHackingLevel() >= server.requiredHackingSkill) && (server.moneyMax > 1)
}

function serverValueSort(ns, h1, h2) {
	const s1 = ns.getServer(h1)
	const s2 = ns.getServer(h2)

	if (s1.moneyMax > s2.moneyMax) return -1
	if (s1.moneyMax < s2.moneyMax) return 1
	return 0
}

function serverRamSortDesc(ns, h1, h2) {
	const s1 = ns.getServer(h1)
	const s2 = ns.getServer(h2)

	if (s1.maxRam > s2.maxRam) return -1
	if (s1.maxRam < s2.maxRam) return 1
	return 0
}

function listServers(ns, hostNames) {
	let hackableHosts = hostNames.filter(serverIsTarget.bind(null, ns)).sort(serverValueSort.bind(null, ns))

	let pservers = ns.getPurchasedServers().sort(serverRamSortDesc.bind(null, ns))
	let serverIdx = 0
	for (const hostName of hackableHosts) {
		ns.tprintf("run exec_max.ns hack_me.ns %s %s", pservers[serverIdx], hostName)
		ns.exec("exec_max.ns", "home", 1, "hack_me.ns", pservers[serverIdx], hostName)
		serverIdx += 1

		if (serverIdx >= pservers.length)
			break
	}
}

export async function main(ns) {
	return
	if (ns.getPurchasedServers().length === 0) {
		ns.tprintf("Unable to run %s when there are 0 purchased servers", ns.getScriptName())
		return
	}

	const hostSet = new Set(["home"])
	let hostQueue = ["home"]
	let currentHost
	while (currentHost = hostQueue.shift()) {
		let newHosts = ns.scan(currentHost)

		for (const newHost of newHosts) {
			if (!hostSet.has(newHost)) {
				hostQueue.push(newHost)
				hostSet.add(newHost)
			}
		}
	}

	let hostNames = Array.from(hostSet)
	listServers(ns, hostNames)
}